// Code generated by mockery v2.51.1. DO NOT EDIT.

package mockpool

import (
	context "context"

	mock "github.com/stretchr/testify/mock"
	pool "github.com/tarantool/go-tarantool/v2/pool"

	tarantool "github.com/tarantool/go-tarantool/v2"

	time "time"
)

// Pooler is an autogenerated mock type for the Pooler type
type Pooler struct {
	mock.Mock
}

// Add provides a mock function with given fields: ctx, instance
func (_m *Pooler) Add(ctx context.Context, instance pool.Instance) error {
	ret := _m.Called(ctx, instance)

	if len(ret) == 0 {
		panic("no return value specified for Add")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, pool.Instance) error); ok {
		r0 = rf(ctx, instance)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Call provides a mock function with given fields: functionName, args, mode
func (_m *Pooler) Call(functionName string, args interface{}, mode pool.Mode) ([]interface{}, error) {
	ret := _m.Called(functionName, args, mode)

	if len(ret) == 0 {
		panic("no return value specified for Call")
	}

	var r0 []interface{}
	var r1 error
	if rf, ok := ret.Get(0).(func(string, interface{}, pool.Mode) ([]interface{}, error)); ok {
		return rf(functionName, args, mode)
	}
	if rf, ok := ret.Get(0).(func(string, interface{}, pool.Mode) []interface{}); ok {
		r0 = rf(functionName, args, mode)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]interface{})
		}
	}

	if rf, ok := ret.Get(1).(func(string, interface{}, pool.Mode) error); ok {
		r1 = rf(functionName, args, mode)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Call16 provides a mock function with given fields: functionName, args, mode
func (_m *Pooler) Call16(functionName string, args interface{}, mode pool.Mode) ([]interface{}, error) {
	ret := _m.Called(functionName, args, mode)

	if len(ret) == 0 {
		panic("no return value specified for Call16")
	}

	var r0 []interface{}
	var r1 error
	if rf, ok := ret.Get(0).(func(string, interface{}, pool.Mode) ([]interface{}, error)); ok {
		return rf(functionName, args, mode)
	}
	if rf, ok := ret.Get(0).(func(string, interface{}, pool.Mode) []interface{}); ok {
		r0 = rf(functionName, args, mode)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]interface{})
		}
	}

	if rf, ok := ret.Get(1).(func(string, interface{}, pool.Mode) error); ok {
		r1 = rf(functionName, args, mode)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Call16Async provides a mock function with given fields: functionName, args, mode
func (_m *Pooler) Call16Async(functionName string, args interface{}, mode pool.Mode) *tarantool.Future {
	ret := _m.Called(functionName, args, mode)

	if len(ret) == 0 {
		panic("no return value specified for Call16Async")
	}

	var r0 *tarantool.Future
	if rf, ok := ret.Get(0).(func(string, interface{}, pool.Mode) *tarantool.Future); ok {
		r0 = rf(functionName, args, mode)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*tarantool.Future)
		}
	}

	return r0
}

// Call16Typed provides a mock function with given fields: functionName, args, result, mode
func (_m *Pooler) Call16Typed(functionName string, args interface{}, result interface{}, mode pool.Mode) error {
	ret := _m.Called(functionName, args, result, mode)

	if len(ret) == 0 {
		panic("no return value specified for Call16Typed")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, interface{}, interface{}, pool.Mode) error); ok {
		r0 = rf(functionName, args, result, mode)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Call17 provides a mock function with given fields: functionName, args, mode
func (_m *Pooler) Call17(functionName string, args interface{}, mode pool.Mode) ([]interface{}, error) {
	ret := _m.Called(functionName, args, mode)

	if len(ret) == 0 {
		panic("no return value specified for Call17")
	}

	var r0 []interface{}
	var r1 error
	if rf, ok := ret.Get(0).(func(string, interface{}, pool.Mode) ([]interface{}, error)); ok {
		return rf(functionName, args, mode)
	}
	if rf, ok := ret.Get(0).(func(string, interface{}, pool.Mode) []interface{}); ok {
		r0 = rf(functionName, args, mode)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]interface{})
		}
	}

	if rf, ok := ret.Get(1).(func(string, interface{}, pool.Mode) error); ok {
		r1 = rf(functionName, args, mode)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Call17Async provides a mock function with given fields: functionName, args, mode
func (_m *Pooler) Call17Async(functionName string, args interface{}, mode pool.Mode) *tarantool.Future {
	ret := _m.Called(functionName, args, mode)

	if len(ret) == 0 {
		panic("no return value specified for Call17Async")
	}

	var r0 *tarantool.Future
	if rf, ok := ret.Get(0).(func(string, interface{}, pool.Mode) *tarantool.Future); ok {
		r0 = rf(functionName, args, mode)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*tarantool.Future)
		}
	}

	return r0
}

// Call17Typed provides a mock function with given fields: functionName, args, result, mode
func (_m *Pooler) Call17Typed(functionName string, args interface{}, result interface{}, mode pool.Mode) error {
	ret := _m.Called(functionName, args, result, mode)

	if len(ret) == 0 {
		panic("no return value specified for Call17Typed")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, interface{}, interface{}, pool.Mode) error); ok {
		r0 = rf(functionName, args, result, mode)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CallAsync provides a mock function with given fields: functionName, args, mode
func (_m *Pooler) CallAsync(functionName string, args interface{}, mode pool.Mode) *tarantool.Future {
	ret := _m.Called(functionName, args, mode)

	if len(ret) == 0 {
		panic("no return value specified for CallAsync")
	}

	var r0 *tarantool.Future
	if rf, ok := ret.Get(0).(func(string, interface{}, pool.Mode) *tarantool.Future); ok {
		r0 = rf(functionName, args, mode)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*tarantool.Future)
		}
	}

	return r0
}

// CallTyped provides a mock function with given fields: functionName, args, result, mode
func (_m *Pooler) CallTyped(functionName string, args interface{}, result interface{}, mode pool.Mode) error {
	ret := _m.Called(functionName, args, result, mode)

	if len(ret) == 0 {
		panic("no return value specified for CallTyped")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, interface{}, interface{}, pool.Mode) error); ok {
		r0 = rf(functionName, args, result, mode)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Close provides a mock function with no fields
func (_m *Pooler) Close() []error {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Close")
	}

	var r0 []error
	if rf, ok := ret.Get(0).(func() []error); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]error)
		}
	}

	return r0
}

// CloseGraceful provides a mock function with no fields
func (_m *Pooler) CloseGraceful() []error {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for CloseGraceful")
	}

	var r0 []error
	if rf, ok := ret.Get(0).(func() []error); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]error)
		}
	}

	return r0
}

// ConfiguredTimeout provides a mock function with given fields: mode
func (_m *Pooler) ConfiguredTimeout(mode pool.Mode) (time.Duration, error) {
	ret := _m.Called(mode)

	if len(ret) == 0 {
		panic("no return value specified for ConfiguredTimeout")
	}

	var r0 time.Duration
	var r1 error
	if rf, ok := ret.Get(0).(func(pool.Mode) (time.Duration, error)); ok {
		return rf(mode)
	}
	if rf, ok := ret.Get(0).(func(pool.Mode) time.Duration); ok {
		r0 = rf(mode)
	} else {
		r0 = ret.Get(0).(time.Duration)
	}

	if rf, ok := ret.Get(1).(func(pool.Mode) error); ok {
		r1 = rf(mode)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ConnectedNow provides a mock function with given fields: mode
func (_m *Pooler) ConnectedNow(mode pool.Mode) (bool, error) {
	ret := _m.Called(mode)

	if len(ret) == 0 {
		panic("no return value specified for ConnectedNow")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(pool.Mode) (bool, error)); ok {
		return rf(mode)
	}
	if rf, ok := ret.Get(0).(func(pool.Mode) bool); ok {
		r0 = rf(mode)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(pool.Mode) error); ok {
		r1 = rf(mode)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Delete provides a mock function with given fields: space, index, key, mode
func (_m *Pooler) Delete(space interface{}, index interface{}, key interface{}, mode ...pool.Mode) ([]interface{}, error) {
	_va := make([]interface{}, len(mode))
	for _i := range mode {
		_va[_i] = mode[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, space, index, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Delete")
	}

	var r0 []interface{}
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, interface{}, interface{}, ...pool.Mode) ([]interface{}, error)); ok {
		return rf(space, index, key, mode...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, interface{}, interface{}, ...pool.Mode) []interface{}); ok {
		r0 = rf(space, index, key, mode...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]interface{})
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, interface{}, interface{}, ...pool.Mode) error); ok {
		r1 = rf(space, index, key, mode...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteAsync provides a mock function with given fields: space, index, key, mode
func (_m *Pooler) DeleteAsync(space interface{}, index interface{}, key interface{}, mode ...pool.Mode) *tarantool.Future {
	_va := make([]interface{}, len(mode))
	for _i := range mode {
		_va[_i] = mode[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, space, index, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteAsync")
	}

	var r0 *tarantool.Future
	if rf, ok := ret.Get(0).(func(interface{}, interface{}, interface{}, ...pool.Mode) *tarantool.Future); ok {
		r0 = rf(space, index, key, mode...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*tarantool.Future)
		}
	}

	return r0
}

// DeleteTyped provides a mock function with given fields: space, index, key, result, mode
func (_m *Pooler) DeleteTyped(space interface{}, index interface{}, key interface{}, result interface{}, mode ...pool.Mode) error {
	_va := make([]interface{}, len(mode))
	for _i := range mode {
		_va[_i] = mode[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, space, index, key, result)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteTyped")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(interface{}, interface{}, interface{}, interface{}, ...pool.Mode) error); ok {
		r0 = rf(space, index, key, result, mode...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Do provides a mock function with given fields: req, mode
func (_m *Pooler) Do(req tarantool.Request, mode pool.Mode) *tarantool.Future {
	ret := _m.Called(req, mode)

	if len(ret) == 0 {
		panic("no return value specified for Do")
	}

	var r0 *tarantool.Future
	if rf, ok := ret.Get(0).(func(tarantool.Request, pool.Mode) *tarantool.Future); ok {
		r0 = rf(req, mode)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*tarantool.Future)
		}
	}

	return r0
}

// Eval provides a mock function with given fields: expr, args, mode
func (_m *Pooler) Eval(expr string, args interface{}, mode pool.Mode) ([]interface{}, error) {
	ret := _m.Called(expr, args, mode)

	if len(ret) == 0 {
		panic("no return value specified for Eval")
	}

	var r0 []interface{}
	var r1 error
	if rf, ok := ret.Get(0).(func(string, interface{}, pool.Mode) ([]interface{}, error)); ok {
		return rf(expr, args, mode)
	}
	if rf, ok := ret.Get(0).(func(string, interface{}, pool.Mode) []interface{}); ok {
		r0 = rf(expr, args, mode)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]interface{})
		}
	}

	if rf, ok := ret.Get(1).(func(string, interface{}, pool.Mode) error); ok {
		r1 = rf(expr, args, mode)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EvalAsync provides a mock function with given fields: expr, args, mode
func (_m *Pooler) EvalAsync(expr string, args interface{}, mode pool.Mode) *tarantool.Future {
	ret := _m.Called(expr, args, mode)

	if len(ret) == 0 {
		panic("no return value specified for EvalAsync")
	}

	var r0 *tarantool.Future
	if rf, ok := ret.Get(0).(func(string, interface{}, pool.Mode) *tarantool.Future); ok {
		r0 = rf(expr, args, mode)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*tarantool.Future)
		}
	}

	return r0
}

// EvalTyped provides a mock function with given fields: expr, args, result, mode
func (_m *Pooler) EvalTyped(expr string, args interface{}, result interface{}, mode pool.Mode) error {
	ret := _m.Called(expr, args, result, mode)

	if len(ret) == 0 {
		panic("no return value specified for EvalTyped")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, interface{}, interface{}, pool.Mode) error); ok {
		r0 = rf(expr, args, result, mode)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Execute provides a mock function with given fields: expr, args, mode
func (_m *Pooler) Execute(expr string, args interface{}, mode pool.Mode) ([]interface{}, error) {
	ret := _m.Called(expr, args, mode)

	if len(ret) == 0 {
		panic("no return value specified for Execute")
	}

	var r0 []interface{}
	var r1 error
	if rf, ok := ret.Get(0).(func(string, interface{}, pool.Mode) ([]interface{}, error)); ok {
		return rf(expr, args, mode)
	}
	if rf, ok := ret.Get(0).(func(string, interface{}, pool.Mode) []interface{}); ok {
		r0 = rf(expr, args, mode)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]interface{})
		}
	}

	if rf, ok := ret.Get(1).(func(string, interface{}, pool.Mode) error); ok {
		r1 = rf(expr, args, mode)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ExecuteAsync provides a mock function with given fields: expr, args, mode
func (_m *Pooler) ExecuteAsync(expr string, args interface{}, mode pool.Mode) *tarantool.Future {
	ret := _m.Called(expr, args, mode)

	if len(ret) == 0 {
		panic("no return value specified for ExecuteAsync")
	}

	var r0 *tarantool.Future
	if rf, ok := ret.Get(0).(func(string, interface{}, pool.Mode) *tarantool.Future); ok {
		r0 = rf(expr, args, mode)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*tarantool.Future)
		}
	}

	return r0
}

// ExecuteTyped provides a mock function with given fields: expr, args, result, mode
func (_m *Pooler) ExecuteTyped(expr string, args interface{}, result interface{}, mode pool.Mode) (tarantool.SQLInfo, []tarantool.ColumnMetaData, error) {
	ret := _m.Called(expr, args, result, mode)

	if len(ret) == 0 {
		panic("no return value specified for ExecuteTyped")
	}

	var r0 tarantool.SQLInfo
	var r1 []tarantool.ColumnMetaData
	var r2 error
	if rf, ok := ret.Get(0).(func(string, interface{}, interface{}, pool.Mode) (tarantool.SQLInfo, []tarantool.ColumnMetaData, error)); ok {
		return rf(expr, args, result, mode)
	}
	if rf, ok := ret.Get(0).(func(string, interface{}, interface{}, pool.Mode) tarantool.SQLInfo); ok {
		r0 = rf(expr, args, result, mode)
	} else {
		r0 = ret.Get(0).(tarantool.SQLInfo)
	}

	if rf, ok := ret.Get(1).(func(string, interface{}, interface{}, pool.Mode) []tarantool.ColumnMetaData); ok {
		r1 = rf(expr, args, result, mode)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).([]tarantool.ColumnMetaData)
		}
	}

	if rf, ok := ret.Get(2).(func(string, interface{}, interface{}, pool.Mode) error); ok {
		r2 = rf(expr, args, result, mode)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetInfo provides a mock function with no fields
func (_m *Pooler) GetInfo() map[string]pool.ConnectionInfo {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetInfo")
	}

	var r0 map[string]pool.ConnectionInfo
	if rf, ok := ret.Get(0).(func() map[string]pool.ConnectionInfo); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]pool.ConnectionInfo)
		}
	}

	return r0
}

// GetTyped provides a mock function with given fields: space, index, key, result, mode
func (_m *Pooler) GetTyped(space interface{}, index interface{}, key interface{}, result interface{}, mode ...pool.Mode) error {
	_va := make([]interface{}, len(mode))
	for _i := range mode {
		_va[_i] = mode[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, space, index, key, result)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetTyped")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(interface{}, interface{}, interface{}, interface{}, ...pool.Mode) error); ok {
		r0 = rf(space, index, key, result, mode...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Insert provides a mock function with given fields: space, tuple, mode
func (_m *Pooler) Insert(space interface{}, tuple interface{}, mode ...pool.Mode) ([]interface{}, error) {
	_va := make([]interface{}, len(mode))
	for _i := range mode {
		_va[_i] = mode[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, space, tuple)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Insert")
	}

	var r0 []interface{}
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, interface{}, ...pool.Mode) ([]interface{}, error)); ok {
		return rf(space, tuple, mode...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, interface{}, ...pool.Mode) []interface{}); ok {
		r0 = rf(space, tuple, mode...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]interface{})
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, interface{}, ...pool.Mode) error); ok {
		r1 = rf(space, tuple, mode...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// InsertAsync provides a mock function with given fields: space, tuple, mode
func (_m *Pooler) InsertAsync(space interface{}, tuple interface{}, mode ...pool.Mode) *tarantool.Future {
	_va := make([]interface{}, len(mode))
	for _i := range mode {
		_va[_i] = mode[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, space, tuple)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for InsertAsync")
	}

	var r0 *tarantool.Future
	if rf, ok := ret.Get(0).(func(interface{}, interface{}, ...pool.Mode) *tarantool.Future); ok {
		r0 = rf(space, tuple, mode...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*tarantool.Future)
		}
	}

	return r0
}

// InsertTyped provides a mock function with given fields: space, tuple, result, mode
func (_m *Pooler) InsertTyped(space interface{}, tuple interface{}, result interface{}, mode ...pool.Mode) error {
	_va := make([]interface{}, len(mode))
	for _i := range mode {
		_va[_i] = mode[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, space, tuple, result)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for InsertTyped")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(interface{}, interface{}, interface{}, ...pool.Mode) error); ok {
		r0 = rf(space, tuple, result, mode...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NewPrepared provides a mock function with given fields: expr, mode
func (_m *Pooler) NewPrepared(expr string, mode pool.Mode) (*tarantool.Prepared, error) {
	ret := _m.Called(expr, mode)

	if len(ret) == 0 {
		panic("no return value specified for NewPrepared")
	}

	var r0 *tarantool.Prepared
	var r1 error
	if rf, ok := ret.Get(0).(func(string, pool.Mode) (*tarantool.Prepared, error)); ok {
		return rf(expr, mode)
	}
	if rf, ok := ret.Get(0).(func(string, pool.Mode) *tarantool.Prepared); ok {
		r0 = rf(expr, mode)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*tarantool.Prepared)
		}
	}

	if rf, ok := ret.Get(1).(func(string, pool.Mode) error); ok {
		r1 = rf(expr, mode)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewStream provides a mock function with given fields: mode
func (_m *Pooler) NewStream(mode pool.Mode) (*tarantool.Stream, error) {
	ret := _m.Called(mode)

	if len(ret) == 0 {
		panic("no return value specified for NewStream")
	}

	var r0 *tarantool.Stream
	var r1 error
	if rf, ok := ret.Get(0).(func(pool.Mode) (*tarantool.Stream, error)); ok {
		return rf(mode)
	}
	if rf, ok := ret.Get(0).(func(pool.Mode) *tarantool.Stream); ok {
		r0 = rf(mode)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*tarantool.Stream)
		}
	}

	if rf, ok := ret.Get(1).(func(pool.Mode) error); ok {
		r1 = rf(mode)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewWatcher provides a mock function with given fields: key, callback, mode
func (_m *Pooler) NewWatcher(key string, callback tarantool.WatchCallback, mode pool.Mode) (tarantool.Watcher, error) {
	ret := _m.Called(key, callback, mode)

	if len(ret) == 0 {
		panic("no return value specified for NewWatcher")
	}

	var r0 tarantool.Watcher
	var r1 error
	if rf, ok := ret.Get(0).(func(string, tarantool.WatchCallback, pool.Mode) (tarantool.Watcher, error)); ok {
		return rf(key, callback, mode)
	}
	if rf, ok := ret.Get(0).(func(string, tarantool.WatchCallback, pool.Mode) tarantool.Watcher); ok {
		r0 = rf(key, callback, mode)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(tarantool.Watcher)
		}
	}

	if rf, ok := ret.Get(1).(func(string, tarantool.WatchCallback, pool.Mode) error); ok {
		r1 = rf(key, callback, mode)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Ping provides a mock function with given fields: mode
func (_m *Pooler) Ping(mode pool.Mode) ([]interface{}, error) {
	ret := _m.Called(mode)

	if len(ret) == 0 {
		panic("no return value specified for Ping")
	}

	var r0 []interface{}
	var r1 error
	if rf, ok := ret.Get(0).(func(pool.Mode) ([]interface{}, error)); ok {
		return rf(mode)
	}
	if rf, ok := ret.Get(0).(func(pool.Mode) []interface{}); ok {
		r0 = rf(mode)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]interface{})
		}
	}

	if rf, ok := ret.Get(1).(func(pool.Mode) error); ok {
		r1 = rf(mode)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Remove provides a mock function with given fields: name
func (_m *Pooler) Remove(name string) error {
	ret := _m.Called(name)

	if len(ret) == 0 {
		panic("no return value specified for Remove")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(name)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Replace provides a mock function with given fields: space, tuple, mode
func (_m *Pooler) Replace(space interface{}, tuple interface{}, mode ...pool.Mode) ([]interface{}, error) {
	_va := make([]interface{}, len(mode))
	for _i := range mode {
		_va[_i] = mode[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, space, tuple)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Replace")
	}

	var r0 []interface{}
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, interface{}, ...pool.Mode) ([]interface{}, error)); ok {
		return rf(space, tuple, mode...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, interface{}, ...pool.Mode) []interface{}); ok {
		r0 = rf(space, tuple, mode...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]interface{})
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, interface{}, ...pool.Mode) error); ok {
		r1 = rf(space, tuple, mode...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ReplaceAsync provides a mock function with given fields: space, tuple, mode
func (_m *Pooler) ReplaceAsync(space interface{}, tuple interface{}, mode ...pool.Mode) *tarantool.Future {
	_va := make([]interface{}, len(mode))
	for _i := range mode {
		_va[_i] = mode[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, space, tuple)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ReplaceAsync")
	}

	var r0 *tarantool.Future
	if rf, ok := ret.Get(0).(func(interface{}, interface{}, ...pool.Mode) *tarantool.Future); ok {
		r0 = rf(space, tuple, mode...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*tarantool.Future)
		}
	}

	return r0
}

// ReplaceTyped provides a mock function with given fields: space, tuple, result, mode
func (_m *Pooler) ReplaceTyped(space interface{}, tuple interface{}, result interface{}, mode ...pool.Mode) error {
	_va := make([]interface{}, len(mode))
	for _i := range mode {
		_va[_i] = mode[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, space, tuple, result)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ReplaceTyped")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(interface{}, interface{}, interface{}, ...pool.Mode) error); ok {
		r0 = rf(space, tuple, result, mode...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Select provides a mock function with given fields: space, index, offset, limit, iterator, key, mode
func (_m *Pooler) Select(space interface{}, index interface{}, offset uint32, limit uint32, iterator tarantool.Iter, key interface{}, mode ...pool.Mode) ([]interface{}, error) {
	_va := make([]interface{}, len(mode))
	for _i := range mode {
		_va[_i] = mode[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, space, index, offset, limit, iterator, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Select")
	}

	var r0 []interface{}
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, interface{}, uint32, uint32, tarantool.Iter, interface{}, ...pool.Mode) ([]interface{}, error)); ok {
		return rf(space, index, offset, limit, iterator, key, mode...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, interface{}, uint32, uint32, tarantool.Iter, interface{}, ...pool.Mode) []interface{}); ok {
		r0 = rf(space, index, offset, limit, iterator, key, mode...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]interface{})
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, interface{}, uint32, uint32, tarantool.Iter, interface{}, ...pool.Mode) error); ok {
		r1 = rf(space, index, offset, limit, iterator, key, mode...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SelectAsync provides a mock function with given fields: space, index, offset, limit, iterator, key, mode
func (_m *Pooler) SelectAsync(space interface{}, index interface{}, offset uint32, limit uint32, iterator tarantool.Iter, key interface{}, mode ...pool.Mode) *tarantool.Future {
	_va := make([]interface{}, len(mode))
	for _i := range mode {
		_va[_i] = mode[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, space, index, offset, limit, iterator, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SelectAsync")
	}

	var r0 *tarantool.Future
	if rf, ok := ret.Get(0).(func(interface{}, interface{}, uint32, uint32, tarantool.Iter, interface{}, ...pool.Mode) *tarantool.Future); ok {
		r0 = rf(space, index, offset, limit, iterator, key, mode...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*tarantool.Future)
		}
	}

	return r0
}

// SelectTyped provides a mock function with given fields: space, index, offset, limit, iterator, key, result, mode
func (_m *Pooler) SelectTyped(space interface{}, index interface{}, offset uint32, limit uint32, iterator tarantool.Iter, key interface{}, result interface{}, mode ...pool.Mode) error {
	_va := make([]interface{}, len(mode))
	for _i := range mode {
		_va[_i] = mode[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, space, index, offset, limit, iterator, key, result)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SelectTyped")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(interface{}, interface{}, uint32, uint32, tarantool.Iter, interface{}, interface{}, ...pool.Mode) error); ok {
		r0 = rf(space, index, offset, limit, iterator, key, result, mode...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Update provides a mock function with given fields: space, index, key, ops, mode
func (_m *Pooler) Update(space interface{}, index interface{}, key interface{}, ops *tarantool.Operations, mode ...pool.Mode) ([]interface{}, error) {
	_va := make([]interface{}, len(mode))
	for _i := range mode {
		_va[_i] = mode[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, space, index, key, ops)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Update")
	}

	var r0 []interface{}
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, interface{}, interface{}, *tarantool.Operations, ...pool.Mode) ([]interface{}, error)); ok {
		return rf(space, index, key, ops, mode...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, interface{}, interface{}, *tarantool.Operations, ...pool.Mode) []interface{}); ok {
		r0 = rf(space, index, key, ops, mode...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]interface{})
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, interface{}, interface{}, *tarantool.Operations, ...pool.Mode) error); ok {
		r1 = rf(space, index, key, ops, mode...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateAsync provides a mock function with given fields: space, index, key, ops, mode
func (_m *Pooler) UpdateAsync(space interface{}, index interface{}, key interface{}, ops *tarantool.Operations, mode ...pool.Mode) *tarantool.Future {
	_va := make([]interface{}, len(mode))
	for _i := range mode {
		_va[_i] = mode[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, space, index, key, ops)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateAsync")
	}

	var r0 *tarantool.Future
	if rf, ok := ret.Get(0).(func(interface{}, interface{}, interface{}, *tarantool.Operations, ...pool.Mode) *tarantool.Future); ok {
		r0 = rf(space, index, key, ops, mode...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*tarantool.Future)
		}
	}

	return r0
}

// UpdateTyped provides a mock function with given fields: space, index, key, ops, result, mode
func (_m *Pooler) UpdateTyped(space interface{}, index interface{}, key interface{}, ops *tarantool.Operations, result interface{}, mode ...pool.Mode) error {
	_va := make([]interface{}, len(mode))
	for _i := range mode {
		_va[_i] = mode[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, space, index, key, ops, result)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateTyped")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(interface{}, interface{}, interface{}, *tarantool.Operations, interface{}, ...pool.Mode) error); ok {
		r0 = rf(space, index, key, ops, result, mode...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Upsert provides a mock function with given fields: space, tuple, ops, mode
func (_m *Pooler) Upsert(space interface{}, tuple interface{}, ops *tarantool.Operations, mode ...pool.Mode) ([]interface{}, error) {
	_va := make([]interface{}, len(mode))
	for _i := range mode {
		_va[_i] = mode[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, space, tuple, ops)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Upsert")
	}

	var r0 []interface{}
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, interface{}, *tarantool.Operations, ...pool.Mode) ([]interface{}, error)); ok {
		return rf(space, tuple, ops, mode...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, interface{}, *tarantool.Operations, ...pool.Mode) []interface{}); ok {
		r0 = rf(space, tuple, ops, mode...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]interface{})
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, interface{}, *tarantool.Operations, ...pool.Mode) error); ok {
		r1 = rf(space, tuple, ops, mode...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpsertAsync provides a mock function with given fields: space, tuple, ops, mode
func (_m *Pooler) UpsertAsync(space interface{}, tuple interface{}, ops *tarantool.Operations, mode ...pool.Mode) *tarantool.Future {
	_va := make([]interface{}, len(mode))
	for _i := range mode {
		_va[_i] = mode[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, space, tuple, ops)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpsertAsync")
	}

	var r0 *tarantool.Future
	if rf, ok := ret.Get(0).(func(interface{}, interface{}, *tarantool.Operations, ...pool.Mode) *tarantool.Future); ok {
		r0 = rf(space, tuple, ops, mode...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*tarantool.Future)
		}
	}

	return r0
}

// NewPooler creates a new instance of Pooler. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewPooler(t interface {
	mock.TestingT
	Cleanup(func())
}) *Pooler {
	mock := &Pooler{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
